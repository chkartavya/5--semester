<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:center;color:#000000;font-family:docs-Calibri,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{background-color:#ffffff;text-align:right;color:#000000;font-family:docs-Calibri,Arial;font-size:11pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:right;color:#000000;font-family:docs-Calibri,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:352px;" class="column-headers-background">A</th><th id="0C1" style="width:165px;" class="column-headers-background">B</th><th id="0C2" style="width:187px;" class="column-headers-background">C</th><th id="0C3" style="width:222px;" class="column-headers-background">D</th><th id="0C4" style="width:167px;" class="column-headers-background">E</th><th id="0C5" style="width:100px;" class="column-headers-background">F</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0">What is an issue with contiguous memory allocation?</td><td class="s0">It leads to memory duplication</td><td class="s0">It is difficult to manage memory addresses</td><td class="s0">Processes can&#39;t share memory</td><td class="s0">Memory fragmentation</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s0">Which of the following is not a necessary condition for a deadlock to occur?</td><td class="s0"> Mutual exclusion</td><td class="s0">Preemption</td><td class="s0">Hold and wait</td><td class="s0">Circular wait</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s0">Which of the following can cause external fragmentation in contiguous memory allocation?</td><td class="s0">Memory sharing between processes</td><td class="s0">Fixed-size memory blocks</td><td class="s0">Variable-size memory blocks</td><td class="s0">Only one process running at a time</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s0">What is a key difference between paging and segmentation?</td><td class="s0">Pages have fixed sizes, while segments have variable sizes</td><td class="s0">Segments have fixed sizes, while pages have variable sizes</td><td class="s0">Segmentation causes internal fragmentation, paging causes external fragmentation</td><td class="s0">Paging provides better memory protection than segmentation</td><td class="s1" dir="ltr">A</td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s0">When a file is deleted in a file system, what must the operating system ensure?</td><td class="s0">The file pointer is set to the end of the file</td><td class="s0">The file is removed from the root directory only</td><td class="s0">All space associated with the file is released</td><td class="s0">The file remains hidden in the directory</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s0">In a paging system, how is the physical address generated?</td><td class="s0">By adding the page number to the frame number</td><td class="s0">By combining the page number and offset</td><td class="s0">By multiplying the page number with the offset </td><td class="s0">By subtracting the offset from the frame number</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s0">In multithreading, what is the main issue that can arise when multiple threads share a common variable without synchronization?</td><td class="s0">Deadlock</td><td class="s0">Thread duplication</td><td class="s0">Race condition</td><td class="s0">Priority inversion</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s0">Which of the following pre-emptive scheduling algorithms is most likely to cause starvation?</td><td class="s0">First-Come, First-Served (FCFS)</td><td class="s0">Shortest Remaining Time First (SRTF) </td><td class="s0">Round Robin </td><td class="s0">Priority Scheduling (Pre-emptive)</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s0">How can race conditions be avoided in a system?</td><td class="s0">By using round-robin scheduling</td><td class="s0"> By allowing processes to access shared resources without locking</td><td class="s0">By running processes on separate processors</td><td class="s0">By ensuring mutual exclusion and proper synchronization mechanisms</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s0">What is a major drawback of the Optimal Page Replacement Algorithm?</td><td class="s0">It causes more page faults than other algorithms</td><td class="s0">It cannot be implemented in practice because it requires future knowledge</td><td class="s0">It requires excessive memory space</td><td class="s0">It only works for small-sized processes</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s0">In the Least Recently Used (LRU) page replacement algorithm, which page is replaced?</td><td class="s0">The page that has not been used for the longest time</td><td class="s0">The page that has been accessed the most recently</td><td class="s0">The page that is about to be accessed next</td><td class="s0">The page that was least recently added</td><td class="s1" dir="ltr">A</td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s0">Thrashing occurs when:</td><td class="s0">The CPU is overloaded with processes</td><td class="s0">Too many pages are loaded into memory at once<br></td><td class="s0">The page replacement algorithm is inefficient<br></td><td class="s0">The operating system spends more time swapping pages than executing processes</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s0">Which deadlock avoidance technique requires that each process declare the maximum number of resources it might need?</td><td class="s0">Banker’s algorithm</td><td class="s0">Circular wait</td><td class="s0">Preemption</td><td class="s0">Wait-for graph</td><td class="s1" dir="ltr">A</td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s0">If a user wants to remove all content from a file without deleting the file itself, which file operation should they perform?</td><td class="s0">Delete operation</td><td class="s0">File truncate operation</td><td class="s0">Seek operation</td><td class="s0">Reset operation</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s0"> Which of the following is true about condition variables in monitors?</td><td class="s0">Condition variables are used for mutual exclusion</td><td class="s0">Condition variables allow threads to wait outside the critical section  </td><td class="s0">Condition variables are used to signal between threads within a monitor</td><td class="s0">Condition variables do not allow any signaling mechanism</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s0">In which directory structure can a single file exist in multiple directories without duplication?</td><td class="s0">Single-level directory</td><td class="s0">Acyclic-graph directory</td><td class="s0">Tree-structured directory</td><td class="s0">Two-level directory</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s0"> Monitors differ from semaphores because:</td><td class="s0">Semaphores are easier to implement than monitors</td><td class="s0">Monitors allow multiple processes to access the critical section simultaneously</td><td class="s0">Monitors do not support process synchronization</td><td class="s0">Monitors automatically handle mutual exclusion</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s0">Which file operation allows the user to change the current position of the file pointer without reading or writing data?</td><td class="s0">Truncate</td><td class="s0">Rewind</td><td class="s0">Seek</td><td class="s0">Write</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s0">In a tree-structured directory, how are files and subdirectories identified uniquely?</td><td class="s0">By their unique name within the directory</td><td class="s0">By their relative path within the system</td><td class="s0">By their file extension</td><td class="s0">By the block size of the file</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s0">What is the primary reason for higher overhead in managing kernel threads compared to user threads?</td><td class="s0"> Kernel threads require more memory.</td><td class="s0">Kernel threads are managed in user space.</td><td class="s0">Kernel threads block the entire process during I/O</td><td class="s0">Kernel threads need to be created and scheduled by the operating system</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s0">Given the burst times for processes P1 (10 ms), P2 (2 ms), P3 (5 ms), and P4 (3 ms), calculate the average turnaround time using the Shortest Job First (SJF) scheduling algorithm.</td><td class="s0"> 10 ms</td><td class="s0">13 ms</td><td class="s0">11 ms</td><td class="s0">12.5 ms</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s0">Which of the following helps prevent processes from overwriting each other’s memory space?</td><td class="s0">Swapping</td><td class="s0">Paging</td><td class="s0">Memory isolation</td><td class="s0">Binding at compile-time</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s0">What is the effect of too many page faults in a demand paging system?</td><td class="s0">Thrashing, leading to reduced system performance</td><td class="s0">Increased process execution speed</td><td class="s0">Lower disk usage</td><td class="s0">Increased memory allocation</td><td class="s1" dir="ltr">A</td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s0">Given burst times of 7 ms, 4 ms, and 6 ms in a Round Robin scheduling system with a time quantum of 3 ms, what is the average waiting time?</td><td class="s0"><br>5 ms</td><td class="s0">6 ms</td><td class="s0">4 ms</td><td class="s0">3 ms</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s0">Which threading model is most appropriate for applications requiring true parallelism in multi-core systems?</td><td class="s0">Many-to-One model</td><td class="s0">User thread model</td><td class="s0">Many-to-Many model</td><td class="s0">One-to-One model</td><td class="s1" dir="ltr">D</td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s0">Which of the following best describes a &quot;lazy swapper&quot; in demand paging?</td><td class="s0">Swaps pages even if they are not needed</td><td class="s0">Swaps pages into memory only when they are requested</td><td class="s0">Swaps the entire process into memory at once</td><td class="s0"> Swaps pages randomly between memory and disk</td><td class="s1" dir="ltr">B</td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s0">In FIFO page replacement, how is the oldest page identified?</td><td class="s0">By using a stack structure</td><td class="s0">By using a priority list</td><td class="s0">By using a queue structure</td><td class="s0">By using a frequency counter</td><td class="s1" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s0">Which thread model allows for the highest degree of portability across different operating systems?</td><td class="s0">Many-to-One model</td><td class="s0">One-to-One model</td><td class="s0">Many-to-Many model</td><td class="s0">Kernel thread model</td><td class="s1" dir="ltr">A</td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s0">Which access method allows users to access a specific record without processing all preceding records?</td><td class="s0">Sequential access<br></td><td class="s0">Batch access </td><td class="s0">Direct access </td><td class="s0">Tape access</td><td class="s2" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s0">Which of the following is a major disadvantage of user threads compared to kernel threads?</td><td class="s0"> Faster context switching</td><td class="s0">No kernel privileges required</td><td class="s0">Blocking system calls block all user threads</td><td class="s0">Portability</td><td class="s2" dir="ltr">C</td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s0">Which of the following page replacement algorithms can suffer from Belady’s Anomaly?</td><td class="s0"> FIFO</td><td class="s0">LRU</td><td class="s0"> Optimal</td><td class="s0"> Clock</td><td class="s2" dir="ltr">B</td></tr></tbody></table></div>